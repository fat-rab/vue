vue 是单向数据流，所以父组件无法修改子组件的数据，如果层级比较多的话，可能出现一些意想不到的问题

计算属性：计算属性是基于其内部的响应式依赖进行缓存的，只有在相关响应式依赖发生改变时，他们才会重新求值，
也可以将一些常量放在计算属性中
方法：没有缓存，每当触发重新渲染的时候，调用方法将总会再次执行函数
watch 监听数据变化，并在监听回调函数中返回数据变更前后的两个值,计算比较大或者异步操作放在计算属性中会阻塞渲染，建议放在watch中

Object.defineProperty
1 不能检测对象属性的添加或者删除
2 不能检测到数组长度变化(通过改变length而添加的长度不能监测到)
3 处于性能考虑，不会对数组的元素进行监听
所以如果想要改变数组并且视图更新的话，可以使用Vue.set(this.$set)添加，Vue.delete(this.$delete)删除 
或者使用push,pop,shift,unshift,splice,sort,reverse这些vue进行过代理包装的方法 
Vue.set(arr,index,data)或者实例上的this.$set //第一个参数为想要改变的数组，第二个是索引，第三个时想要添加的数据
Vue.delete(arr,index)

事件修饰符
事件修饰符可以串联 click.stop.prevent
@click.stop  开发组件的时候，为了保证methods方法只有纯粹的数据逻辑（和dom解耦，易于单元测试），不去处理dom相关操作
stop:组织点击事件冒泡
prevent 阻止默认事件 a标签就是不在跳转
capture 添加事件监听器时使用事件捕获模式
self只有当event.target时当前元素自身的时候触发处理函数
once 点击事件只会触发一次
passive 滚动事件的默认行为将会立即触发
enter 只有在key时enter的时候才会触发

动态组件


who可以通过计算属性返回具体的组件
who?'com1':'com2'
如果使用,可以缓存组件实例，通过vm.$el获取先前的dom元素，然后直接插入到页面中去
<keep-alive>
<component :is="who"></component>
</keep-alive> 

keep-alive 
include 字符串或者正则表达式，只有名称匹配的组件会被缓存
exclude 字符串或者正则表达式，任何名称匹配的组件都不会被缓存
max 数字，最多可以缓存多少组件实例
使用keep-alive 之后，子组件会多两个声明周期
activated keep-alive内组件加载成功后调用
deactivated keep-alive内组件缓存成功后调用


路由
vue-router 会有一个监听器，用来监听浏览器History的变化，通常境况下，浏览器的地址改变或者点击了浏览器的前进后退按钮，history的历史栈会改变
当监听到history改变之后，vuerouter会更具路由表中申明了的路由对应匹配的组件，通过routerView组件对VuePage的渲染

如何监听
Hash
http://www.baidu.com#/xxxx (xxxx就是哈希值)
当哈希改变的时候，页面不会刷新，但是会触发onhashchange事件
window.onhashchange=function(){console.log(location.hash)} //location.hash为当前hash
History
点击浏览器前进后退按钮，history.go() history.back() history.forward() =>（ 等价于点击前进按钮或调用 history.go(1) ）的时候触发
window.addEventListener("popstate",function(){console.log(window.location.pathname)})
可以通过history.pushState({},"title","xxxx")添加历史栈或者history.replaceState({},"title","xxxx")替换历史栈，但是不会触发popstate事件